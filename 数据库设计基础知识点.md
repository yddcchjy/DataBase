### **数据库领域中主要的逻辑数据模型有：**

1. 层次模型（树） 

2. 
   网状模型(一个以上可以没有双亲，一个节点可以有多于一个的双亲) 

3. 关系模型 

4. 面向对象模型 

5. 对象关系数据模型 

6. 半结构化数据模型


### 数据库系统的三级模式结构 ：

1. 模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。它与数据的物理存储细节和硬件环境无关，又与具体的应用程序、所使用的应用开发工具及高级程序设计语言无关。定义数据的逻辑结构：数据项的名字，类型，取值范围；定义数据之间额联系：定义与数据有关的安全性、完整性的要求。

2. 外模式也成子模式或用户模式，他是数据库用户包括程序员和最终用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。一个数据库可以有多个外模式。保证数据的安全性

3. 内模式也成存储模式，一个数据库只有一个内模式。用什么索引？B+树索引还是Hash索引；数据是否压缩存储，是否加密等。


### 数据库的二级映像功能与数据独立性

1. 外模式/模式映像：

2. 模式/内模式映像:


----

- 域：
  - 域是一组具有相同数据类型的值的集合。

- 笛卡尔积：

  - 其中每一个元素（d1,d2,...,dn）叫做n元组，或元组。元素中的每一个值di叫做一个分量。

- 一个域允许的不同取值个数称为这个域的基数。


- 候选码：
  - 若关系中的某一属性的值能唯一标识一个元组，而其子集不能，则称该属性组为候选码。

- 主码：
  - 一个关系有多个候选码，则选定其中一个。

- 主属性：
  - 候选码的诸属性。

- 非主属性/非码属性：
  - 不包含在任何候选码中的属性。

- 全码：

  - 在最极端情况下，关系模式的所有属性是这个关系模式的候选码。

  关系有三种类型：基本关系（实际存在的表）/查询表/视图表

- 关系的完整性：
  - 若属性(指一个或一组属性)A是基本关系R的主属性，则A不能取空值。

- 参照关系：
  - 设F是基本关系R的一个或一组属性，但不是关系R的码，Ks是基本关系S的主码。如果F与Ks相对应，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系或目标关系。

- 参照完整性：
  - 若属性或属性组F是基本关系R的外码，它与基本关系S的主码Ks相对应，则对于R中的每个元祖在F上的值必须：
    - 或者取空值（说明还未分配）
    - 或者等于S中某个元祖的主码值

- 用户自定义完整性

  - 例如某个属性必须取唯一值，某个非主属性不能取空值

----------
### 数据库安全性控制：

- 授权与收回：grant revoke


```sql
grant select on table student to user1;

grant all privileges on table student to user2;

grant select on table student to public;

grant insert on table student with grant option

revoke update(sno) on table student from user4;

revoke select on table student from public;

revoke select on tabel student from user5 cascade;
```

- 创建角色


	create role r1;

----------
### 数据库完整性:

#### 	1.实体完整性

   		1.表级定义主码:

​				若一个表要设置两个属性为主键时，只能在表级定义主码

```sql
create table student (
	sno int ,
	sname char,
	primary key(sno,sname)	
) -- 表级定义主码
```



​	 	2. 列级定义主码：

```sql
create table student(
    sno int primary key,
    sname char
)
```

关系型数据库一般都在主码上自动建立一个索引。



#### 2.参照完整性

	create table sc(
		sno int ,
		cno int ,
		foreign key(sno)references student(sno)
	)

- 拒绝执行 no action 

- 级联操作 cascade

- 设置为空值


	create table sc(
		sno int,
		cno int,
		foreign key(cno) references course(cno) 
		on delete cascade on update cascade
	)



### 3.用户自定义完整性

- 列值非空 not null

- 列值唯一 unique

- 检查列值是否满足一个条件表达式 check短语


1. 属性上的约束条件：


	create table student (
		sno int not null unique,
		sex char check(sex in ('男','女'))
	)

​	2. 元组上的约束条件：

	create table studnet (
		sno int not null,
		sex char,
		sage int,
		check(sex = '女' and sage > 20)	
	)



### 4.完整性约束命名子句

在create table 语句中提供了完整性约束命名子句constraint，可灵活地增加、删除一个完整性约束条件。

	create table student(
		sno int constraint c1 check(sno between 1 and 10)
	)
	
	alter table student
		drop constraint c1;
	
	alter table student
		add contrraint c1 check(sno between 11 and 20) -- add的意思是在以前的基础上修改，而不是增加。



### 5.断言

格式：create assertion <断言名><check子句>

	create assertion asse_num
		check(60 >= (select count(*) from course,sc 
			where course.name = '数据库')and course.cno = sc.cno))



### 6.触发器

​	是用户定义在关系表上的一类由事件驱动的特殊过程。

​	格式：

```
create trigger <触发器名>
	{before|after} <触发事件>on <表名>
	referencing new|old row as<变量>
	for each{row|stacement}
	[when<触发条件>]<触发动作体>
```


​	例子1：当对sc的grade属性修改时，若分数增加了10%，则将此操作记录到另外一个表中。

	create trigger sc_t
	after update of grade on sc
	referencing 
		oldrow as oldtuple
		newrow as newtuple
	for each row
	when(newrow.grade >= 1.1*oldtuple.grade)
		insert into sc_u values(oldtuple.sno,oldtuple.cno,oldtuple.grade,newtuple.grade)

​	例子2：将每次对表student的插入操作所增加的学生个数记录到另一个表中

	create trigger student_count
	after insert on student
	referencing
		new table as delta
	for each statement
		insert into log(numbers)
		select count(*)from delta
	
	delta 是一个关系名，其模式与student相同，包含的元组是insert语句增加的元祖。

```
		drop trigger <触发器名>on <表名>
```

----------



### 规范化：

- 每一个分量必须是不可分的数据项。第一范式

- 符合第一范式，且每一个非主属性完全依赖于任何一个候选码。第二范式

- 每一个非主属性不传递依赖于码，也不部分依赖于码。第三范式

- 所有非主属性对每个码都是完全函数依赖

- 所有主属性对每一个不包含他的码也是完全函数依赖

- 没有任何属性完全依赖于非码的任何一组属性。 BCNF



### 数据字典：

- 是进行详细的数据收集和数据分析所获得的主要成果。

- 包括：数据项、数据结构、数据流、数据存储、处理过程。


----------
#### 原则1：

​	ER图中的每一个独立实体变换为一个关系，其属性变为关系的属性，其主标识变为关系的主码。例如，图中独立实体“部门”、“职员”分别变为部门关系、职员关系。

#### 原则2：

​	ER图中的从实体及相应的“的”联系变换为一个关系，从实体的属性加上主实体关系的主码构成这个关系的属性。如果“的”联系是1：1的，则以主实体关系的主码（作为外来码）为这个关系的主码；如果“的”联系是1：M的，则以主实体关系的主码加上同一主实体个体联系的不同从属实体个体赖以相互区分的属性组，组成该关系的主码。

#### 原则3：

​	1：M联系通过在“多”实体关系中增加相联系的“1”实体关系的主码及联系本身的属性来表达。其中“1”实体主码为外来码。例如，在员工关系中增加“所属部门号”这个外来码反映1：M联系所属职员关系。

#### 原则4：

​	M：N联系转换成一个独立的关系，被联系实体关系的主码（作为外来码）和联系本身的属性作为该关系的属性，被联系实体关系的主码组成其复合主码。

----------
### 存取方法：

#### B+树索引存取方法：

​	根据应用要求确定对关系的那些属性列建立索引。那些属性列建立组合索引、那些索引要设计唯一索引。

- 如果一个或一组属性经常在查询条件中出现，则考虑在这个、这组属性上建立索引、组合索引。
- 如果一个属性经常作为最大值和最小值等聚集函数的参数，则考虑在这个属性上加索引。
- 如果一个或一组属性经常在连接操作的连接条件中出现，则考虑加索引。

#### hash索引存取方法的选择：

​	如果一个关系的属性主要出现在等值条件连接条件中或主要出现在等值比较选择条件中，而且满足以下之一，则可选择hash存取：

- 一个关系的大小可预知，而且不变
- 关系的大小动态改变，但数据库管理系同提供了动态hash存取方法

#### 聚簇存取方法的选择：

​	把这个或这些属性上具有相同值的元组集中存放在连续的物理块中称为聚簇。该属性或属性组称为聚簇码。 

- 经常一起进行连接操作的关系可以建立聚簇。
- 如果一个关系的一组属性经常出现在相等比较条件中，则该单个属性可以建立聚簇。
- 如果一个关系的一个或一组属性上的值重复率很高，则单个关系可建立聚簇。？？？p237

----------



### 关系查询处理和查询优化

​	**实现查询操作的算法：**

​		**1.选择操作的实现**

	select * from student where <>
	
		c1:无条件
	
		c2：sno='1'
	
		c3:sage>20
	
		c4:sdept = 'cs' and sage >20

(1)简单的全表扫描算法：

- 按照为例次序读student的m块到内存

- 检查内存的每个元祖t，如果t满足选择条件，则输出t

- 如果student还有其他块未被处理，则输出t


(2)索引扫描算法：

​	如果选择条件中的属性上有索引（B+索引或hash索引），可以用索引扫描算法，通过索引先找到满足条件的元祖指针，在通过元组在student表中检索到该学生。

- c2：若sno上有索引，使用索引得到sno为1元组的指针，再通过元组指针在student表中检索到该学生。


- c3：sage>20,并且sage上有b+树索引，则可以使用b+树索引找到sage索引项，以此为入口点在b+树上得到sage>20的所有元组指针，然后通过这些指针到studnet表中检索到所有年龄大于20的学生。


- c4:

  - ①如果sdept和sage上都有索引，分别用上面两种方法找到各自的元祖指针，求出两组指针的交集，再到studnet表中检索，得出结果。

  - ②只有sdept上有索引，通过元组指针到student表中检索，并得到的元组中检查另一个条件是否满足，得出结果。

    

  **2.连接操作的实现**


  是查询处理中最耗时的操作之一

	select * from student,sc where student.sno = sc.sno;

​	（1）嵌套循环算法：

​		实际实现中数据存取是按照数据块读入内存，而不是按照元组进行i/o的。

​	（2）排序-合并算法：

​		这是等值连接常用的算法。尤其适合参与连接的诸表已经排好序的情况。

​	（3）索引连接算法：

- 在sc表中已经建立好了属性sno的索引
- 对student中的每一个元组，由sno值通过sc的索引查找相应的sc元组
- 把这些sc元组和student元组连接起来。


​	（4）hash join算法

  它把用作连接的属性作为hash码，用同一个hash函数吧student表和sc表中的元组散列到hash表中。

- 划分阶段，把元组按hash函数分散到hash表的桶中
- 试探阶段/连接阶段，对另一个hash表进行一遍处理，把sc表的元组也按同一个hash函数尽心散列，找到适当的hash桶，并把sc元组与桶中来自student表并与之相匹配的元组连接起来。

**查询优化**

	select studnet,sname 
		from studnet,sc
			where student.sno = sc.sno and sc.cno = '2'



**查询树的启发式优化**

- 选择运算应尽可能先做
- 把投影运算和选择运算同时进行
- 把投影同其前或后的双目运算结合起来
- 把某些选择同在它前面要执行的笛卡尔积结合起来称为一个连接运算
- 找出公共子表达式

----------


### **数据库恢复技术：**

​	事务处理技术主要包括**数据库恢复技术**和并发控制技术

事务：

​	是用户定义一个数据库序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。一个事务可以是一条sql语句、一组sql语句、或整个程序。

事务的开始和结束需要用户显式的控制，若没有显式的定义事务，则有数据库管理系统按默认规定自动划分事务。

**定义事务的语句**：

- begin transaction
- commit -将事务中所有对数据库的更新写回到磁盘上的物理数据库中
- rollback

**事务的ACID特性：**

- 原子性
   - 事务是数据库的逻辑工作单位，事务中包括的操作要么全都做，要么全都不做。

- 一致性
   - 事务的执行结果必须是从一个一致性状态到另一个一致性状态。
      - ①当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态
      - ②如果数据库系统运行发生故障，有些事务未完成就被迫中断，这些未完成的事务对数据库所做的修改有部分已经写入数据库，这时数据库就处于一种不正确的状态，就称做不一致性状态。

- 隔离性
   - 一个事务的执行不能被其他事物干扰。即一个事务的内部操作及使用的数据对其他并发事务也是隔离的，并发执行的各个事务之间不能互相干扰。

- 持续性/永久性
   - 指一个事务一旦提交，只一个事务一旦提交，他对数据库的改变就是永久性的，接下来的其他操作或故障不应该对其执行结果产生影响。


**破坏事务ACID特性的因素**
- 多个事务并行s时，不同事务的操作交叉进行。/要求不影响
- 事务在运行过程中被强行停止。/要求不影响

**故障的种类**：

- 事务内部的故障（有些可以由程序发现，但有的是非预期的（运算溢出，并发死锁），不能由事务程序处理） 
   - 程序可以发现的：转账金额不足，进行事务撤销处理，rollback
- 系统故障/软故障（指造成系统停止运转的任何事件，使得系统要重新启动）
   - 特定类型的硬件错误（cpu错误），操作系统故障，DBMS代码错误，系统断电
   - 会影响正在运行的所有事务，不会破坏数据库。
   - 为保证一致性，需要清除这些事务对数据库的所有修改。
- 介质故障/硬故障
   - 磁盘损坏，磁头碰撞、瞬时磁场干扰
  - 计算机病毒

**恢复的实现技术：**

​	建立冗余的数据。

**数据转储**：

​	数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程，这些备用数据称为后备副本或后援副本。

使用场景：数据库被破坏后，重装副本将数据库恢复到转储时的状态。如果要恢复到发生故障时的状态，则要执行转储后的所有更新事务。

转储又分为静态转储跟动态转储。

- 静态转储是无运行事务进行的转储操作。
- 动态转储是允许数据库进行存取或修改。转储和用户事务可以并发进行。
 - 为避免转储时，有用户事务运行；转储完成之后副本中的数据跟现在正确的数据不一致，所以要将上述的用户事务以日志文件的形式记录下来。这样后援副本+日志文件就能把数据库恢复到某一时刻的正确状态。

转储还可分为增量转储跟海量转储。



**登记日志文件**
	用来记录事务对数据库的更新操作。

作用：

- 事务故障恢复和系统故障恢复必须使用日志文件。
- 在动态转储中必须建立日志文件。后备副本+日志文件=有效的恢复数据库
- 静态转储方式也可以建立日志文件；
  - ①当数据库被破坏后装入后备副本（恢复到转储结束时的正确状态）
  - ②利用日志文件把已完成的事务进行重做，对故障发生后还未完成的事务进行撤销处理（恢复到故障前某一时刻的正确状态）

规则：

- 登记的次序严格按并发事务执行的时间次序。
- 必须先写日志文件，后写数据库。



